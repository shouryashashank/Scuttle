// main.rs is the entry point for our command-line application.
// We'll use the `clap` crate to handle arguments.
use clap::{Parser, Subcommand};
use std::path::PathBuf;

// Import the `process_upload` function from our library (lib.rs).
// The `scuttle` module is automatically generated by Cargo from our crate name.
use scuttle::process_upload;
use scuttle::process_download;
use scuttle::process_init;
use scuttle::process_setup;
use scuttle::process_status;
use scuttle::process_add;
use scuttle::process_commit;
use scuttle::process_push;

#[tokio::main]
async fn main() {
    if let Err(e) = run_app().await {
        eprintln!("Error: {:?}", e);
    }
}

async fn run_app() -> anyhow::Result<()> {
    let args = Cli::parse();

    match args.command {
        // Here, we handle the `upload` command.
        Commands::Upload { path, remote_name } => {
            // We call the function from our `lib.rs` to handle the logic.
            process_upload(&path, remote_name.as_deref()).await?;
        }
        Commands::Download { remote_path, remote_name } => {
            process_download(&remote_path, remote_name.as_deref()).await?;
        }
        Commands::Init { } => {
            process_init().await?;
        }
        Commands::Setup { } => {
            process_setup().await?;
        }
        Commands::Status { } => {
            process_status().await?;
        }
        Commands::Add { paths } => {
            process_add(&paths).await?;
        }
        Commands::Commit { message } => {
            process_commit(&message).await?;
        }
        Commands::Push { remote_name } => {
            process_push(remote_name.as_deref()).await?;
        }
    }

    Ok(())
}

/// A command-line tool for synchronizing files between local storage and the cloud.
#[derive(Parser)]
#[clap(author, version, about)]
struct Cli {
    #[clap(subcommand)]
    command: Commands,
}

// Define the available subcommands.
#[derive(Subcommand)]
enum Commands {
    /// Uploads a file to the configured cloud service.
    Upload {
        /// The path to the file you want to upload.
        path: PathBuf,
        /// Optional remote name to specify which remote to use.
        #[clap(long, value_name = "remote-name")]
        remote_name: Option<String>,
    },
    /// Downloads a file from the configured cloud service.
    Download {
        /// The path to the file you want to download.
        remote_path: String,
        /// Optional remote name to specify which remote to use.
        #[clap(long, value_name = "remote-name")]
        remote_name: Option<String>,
    },
    /// Initializes the configuration for the cloud service.
    Init {
    },
    Setup {
    },
    /// Shows the status of local files compared to tracked files.
    Status {
    },
    /// Adds files to the staging area.
    Add {
        /// Paths of files to add.
        paths: Vec<PathBuf>,
    },
    /// Commits the current state with a message.
    Commit {
        /// Commit message
        #[clap(short = 'm', long = "message")]
        message: String,
    },
    /// Pushes staged files to the configured remote.
    Push {
        /// Optional remote name to specify which remote to use.
        #[clap(long, value_name = "remote-name")]
        remote_name: Option<String>,
    },
}